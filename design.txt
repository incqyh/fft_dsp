几点说明:
    1. 所有输入归一化成小数
    2. 所有数据使用1.15定点数表示，计算时可能会有精度误差

底层函数:
    1. 复数乘法
        将两个乘数分别存入MX0, MY0; MX1, AY1。
        将所乘得的结果存入MX0，MY0
    2. 系数获取，将所有fft使用的系数存入coeff_(real|virtual).dat文档中直接读出
    3. 三角函数求值 //此方法之后没有使用
        在考察cordic算法的实现方案之后认为该算法复杂度过高，不利于快速求解fft。
        所以分别在一个周期内均匀取sin和cos的值各100个，存入文件sin_vlaue.dat|cos_value.dat，
        在使用时按照线性插值的方法来获取每个坐标所对应的函数值。
        计算过程中使用1来代替2*pi，这是为了防止出现大于1的数出现。

fft实现:
    1. bit级顺序颠倒
        按时间抽取的fft需要在一开始转换数据顺序，转换过程为将转换后的顺序存储到文件中
        每次读取当前位置需要存入的数据，执行排序操作
    2. fft过程
        fft蝶形需要三层循环，每前进一列为经过一个循环单元，每个蝶形组为一个循环单元，单个蝶形组内部为一个循环单元
        此处使用SR0，AX1，AY1来扮演循环计数功能
        其中SR0为8-4-2-1-0，当达到0最外层循环结束
        AY1为1-2-4-8，它的作用为指明用来求解下一个数据所需要的两个数据之间的内存地址间隔
        AX1为每次自加1，不超过当前的AY值即可

测试:
    1. 使用c++写一份fft，来计算每一步的数据，与dsp运算结果进行比对
    2. 由于dsp获取到的是1.15定点数，所以使用python处理一下数据转换为十进制可读数据